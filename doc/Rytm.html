<!DOCTYPE html><html lang="en"><head><title>Rytm</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="Rytm"><meta name="groc-project-path" content="Rytm.js"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path">Rytm.js</div></div><div id="document"><div class="segment"><div class="comments"><div class="wrapper"><h1 id="apis-and-annotation">APIs and Annotation</h1></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="multiple-environment-support">Multiple environment support</h2>

<p>Rytm supports multiply JavaScript environment including:</p></div></div><div class="code"><div class="wrapper"><span class="p">;(</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">factory</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">Rytm</span> <span class="o">=</span> <span class="nx">factory</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">require</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">define</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">define</span><span class="p">.</span><span class="nx">amd</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>AMD loader such as requirejs or curl: 
<code>require('path/to/rytm', callback);</code></li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="nx">define</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="k">return</span> <span class="nx">Rytm</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">exports</span> <span class="o">!=</span> <span class="s1">&#39;undefined&#39;</span><span class="err">ã€€</span><span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">module</span> <span class="o">!=</span> <span class="s1">&#39;undefined&#39;</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>Nodejs module loading:
<code>var Rytm = require('path/to/rytm');</code></li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">Rytm</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li><code>Rytm</code> will be a global variable if its factory was ran 
without AMD loader</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">this</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">Rytm</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">})</span>

<span class="p">(</span><span class="s2">&quot;Rytm&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">global</span><span class="p">,</span> <span class="nx">undef</span><span class="p">){</span>
    <span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

    <span class="kd">var</span> <span class="nx">ver</span> <span class="o">=</span> <span class="s1">&#39;0.1&#39;</span><span class="p">;</span>

    <span class="cm">/* Shims */</span>
    <span class="kd">var</span> <span class="nx">noop</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">global</span><span class="p">.</span><span class="nx">etui</span><span class="p">){</span>
        <span class="nx">noop</span> <span class="o">=</span> <span class="nx">global</span><span class="p">.</span><span class="nx">etui</span><span class="p">.</span><span class="nx">noop</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">global</span><span class="p">.</span><span class="nx">jQuery</span><span class="p">){</span>
        <span class="nx">noop</span> <span class="o">=</span> <span class="nx">global</span><span class="p">.</span><span class="nx">jQuery</span><span class="p">.</span><span class="nx">noop</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="nx">noop</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){};</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">bind</span> <span class="o">=</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span> <span class="o">||</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">slice</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">__method</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
        <span class="nx">args</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
        <span class="k">return</span> <span class="kd">function</span> <span class="nx">wrapper</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">wrapper</span><span class="p">){</span>
                <span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nx">__method</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)));</span>
        <span class="p">};</span>
    <span class="p">});</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="constructor">Constructor</h2>

<p>Create Rytm instance and also loads the tasks</p>

<p><code>var r = new Rytm(task1, task2, task3 ... )</code></p>

<h3 id="parameters">Parameters</h3>

<ul>
<li>task1-n: Tasks/callbacks which to be executed in order</li>
</ul>

<h3 id="tips-and-annotations">Tips and Annotations</h3>

<ul>
<li>Tasks can also be added later by calling <code>instance.beat</code></li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="cm">/* </span>
<span class="cm">        Constructor</span>
<span class="cm">    */</span>
    <span class="kd">var</span> <span class="nx">Rytm</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>You can also create new instance the 'creator' style:
<code>var r = Rytm()</code></li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Rytm</span><span class="p">)){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="p">(</span><span class="nx">bind</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">Rytm</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">))();</span>
        <span class="p">}</span>
    
        <span class="k">this</span><span class="p">.</span><span class="nx">steps</span> <span class="o">=</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">_createNode</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>The "head node" simply redirect the calls to next step</li>
</ul></div></div><div class="code"><div class="wrapper">            <span class="k">this</span><span class="p">.</span><span class="nx">_go</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        <span class="p">})];</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>this.cursor.value is actually shared between TaskContexts</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">this</span><span class="p">.</span><span class="nx">cursor</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">value</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">};</span>
        </div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>Creates <code>go()</code>, which wraps <code>_go()</code>, make sure the context of <code>go()</code> is always current
instance</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">this</span><span class="p">.</span><span class="nx">go</span> <span class="o">=</span> <span class="nx">bind</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_go</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">defer</span> <span class="o">=</span> <span class="nx">bind</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">defer</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">wait</span> <span class="o">=</span> <span class="nx">bind</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">wait</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>Constructor will automatically load callbacks which passed in constructor as 
tasks</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="nx">loadSteps</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        
    <span class="p">};</span>

    <span class="nx">Rytm</span><span class="p">.</span><span class="nx">ver</span> <span class="o">=</span> <span class="nx">ver</span><span class="p">;</span>
    

    <span class="cm">/*</span>
<span class="cm">        @private loads steps from arguments</span>
<span class="cm">    */</span>
    <span class="kd">function</span> <span class="nx">loadSteps</span><span class="p">(</span><span class="nx">args</span><span class="p">){</span>

        <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
            <span class="kd">var</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">cur</span> <span class="o">!=</span> <span class="s2">&quot;function&quot;</span><span class="p">){</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">beat</span><span class="p">(</span><span class="nx">cur</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">Rytm</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

    <span class="nx">p</span><span class="p">.</span><span class="nx">_inNextCallContext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="-createnode">_createNode</h2>

<p>A private method which not supposed to be used externally,
it creates a node which can be used in the task sequence.</p>

<h3 id="schema">Schema</h3>

<pre><code> {
     // callback - the actual 'task function' in current task
     callback: actuallTaskFunc,
     // next - the reference to next node in sequence
     next: nextNode,
     // prev - the reference to prev node
     prev: prevNode
     // lastCalls - An array that stores callback which returned 
     // by `all()`
     lastCalls: [],
     // ticked - true means execution of current task is done
     // and it is safe to advance to next task
     ticked: false
     // went - true to means the cursor advancing is already done
     // and do not do it again.
 }
</code></pre></div></div><div class="code"><div class="wrapper">  <span class="nx">p</span><span class="p">.</span><span class="nx">_createNode</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">next</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">next</span> <span class="o">===</span> <span class="nx">undef</span><span class="p">){</span>
      <span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">callback</span><span class="o">:</span> <span class="nx">callback</span><span class="p">,</span> 
            <span class="nx">next</span><span class="o">:</span> <span class="nx">next</span><span class="p">,</span> 
            <span class="nx">prev</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
            <span class="nx">lastCalls</span><span class="o">:</span> <span class="p">[],</span>
            <span class="nx">args</span><span class="o">:</span> <span class="p">[],</span>
            <span class="nx">ticked</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> 
            <span class="nx">went</span><span class="o">:</span> <span class="kc">false</span>
        <span class="p">};</span>
    <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="current">current</h2>

<p>Get current task node</p>

<h3 id="tips-and-annotations">Tips and Annotations</h3></div></div><div class="code"><div class="wrapper">    <span class="nx">p</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>It will check if we are in TaskContext, if we are,
the cursor is locked, it will return the locked cursor.</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_current</span><span class="p">){</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_current</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">){</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">prev</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">steps</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">steps</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">};</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="beat">beat</h2>

<p>Add a callback to the execution sequence</p>

<h3 id="parameters">Parameters</h3>

<ul>
<li>callback: The task/callback to be added</li>
</ul>

<h3 id="tips-and-annotations">Tips and Annotations</h3></div></div><div class="code"><div class="wrapper">  <span class="nx">p</span><span class="p">.</span><span class="nx">beat</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
            <span class="nx">loadSteps</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
        <span class="kd">var</span> <span class="nx">stepStruct</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_createNode</span><span class="p">(</span><span class="nx">callback</span><span class="p">),</span>
                <span class="nx">lastStep</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">steps</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">steps</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

            <span class="nx">stepStruct</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">lastStep</span><span class="p">;</span>
        <span class="nx">lastStep</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">stepStruct</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">steps</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">stepStruct</span><span class="p">);</span>
        </div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>Once current Rytm instance executed
and after the execution of current instance
there are newly added tasks, go() will start
from previous stop point and work through the 
newly added task exclusively</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">null</span><span class="p">){</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">stepStruct</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">}</span>
    
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="step">step</h2>

<p>An alias of <code>beat</code> for backward compatibility.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">p</span><span class="p">.</span><span class="nx">step</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">beat</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="wait">wait</h2>

<p>When called, a built-in step will be added to the sequence for pausing
a specified millisecond, and pass the arguments to next task.</p>

<ul>
<li>wait: Specifiy the millisecond to wait.</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nx">p</span><span class="p">.</span><span class="nx">wait</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">timeout</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

    <span class="nx">s</span><span class="p">.</span><span class="nx">step</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>

      <span class="nx">s</span><span class="p">.</span><span class="nx">defer</span><span class="p">(</span><span class="nx">timeout</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="p">});</span>
    
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="go">go</h2>

<p>A wrapper of <code>_go()</code> with bounded context. You can feel free to
call <code>go</code> or pass <code>go</code> to any async function as a callback method without
worrying the changing of context.</p>

<h3 id="usage">Usage</h3>

<pre><code>function asyncCall(callback){
    setTimeout(function(){
        callback.call({});
    }, 0)
}

(new Rytm(function(){
    // no worry, simply pass it to anything you want
    asyncCall(this.go);
})).go();
</code></pre></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="-go">_go</h2>

<p>When called, execute the next step immediately (context-binding-free).</p>

<h3 id="tips-and-annotations">Tips and Annotations</h3></div></div><div class="code"><div class="wrapper">  <span class="nx">p</span><span class="p">.</span><span class="nx">_go</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    
    <span class="kd">var</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">,</span> <span class="nx">current</span><span class="p">,</span> <span class="nx">contextualScope</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li><code>go()</code> can force <code>this</code> points to the instance of Rytm,
so in most case we don't have to check this._instance.</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_instance</span><span class="p">){</span>
            <span class="nx">contextualScope</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_instance</span><span class="p">;</span>
        <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>_go() will check if we are in a nested <code>next()</code> calling context
by visiting _inNextCallContext
if we are, we will have to skip same step because they might already
be called. </li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">while</span> <span class="p">(</span><span class="nx">contextualScope</span><span class="p">.</span><span class="nx">_inNextCallContext</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
            
            <span class="nx">contextualScope</span><span class="p">.</span><span class="nx">_inNextCallContext</span><span class="o">--</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">prev</span><span class="p">){</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">prev</span><span class="p">.</span><span class="nx">went</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">went</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">next</span><span class="p">){</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="k">throw</span> <span class="s2">&quot;Rytm: Strangely we are in a nested context &quot;</span>
                    <span class="s2">&quot;but there is no cursor.next available, must be a bug.&quot;</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">null</span><span class="p">){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="nx">callback</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">callback</span><span class="p">;</span>

        <span class="cm">/* TODO: tick cursor here */</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">callback</span> <span class="o">==</span> <span class="kc">null</span><span class="p">){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

        <span class="nx">current</span> <span class="o">=</span> <span class="nx">contextualScope</span><span class="p">.</span><span class="nx">current</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">current</span><span class="p">){</span>
            <span class="nx">current</span><span class="p">.</span><span class="nx">went</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">TaskContext</span><span class="p">){</span>
            <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">createTaskContext</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_instance</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">createTaskContext</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>and then advance to next</p></div></div><div class="code"><div class="wrapper">        <span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>

    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>_go() will also check if the current task has a return value
if there is, then consider the result as the parameter of
next task
p.s. return false will also cause immediate execution of next
<code>beat</code></li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="o">!==</span> <span class="nx">undef</span><span class="p">){</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">go</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="p">}</span>
    
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="defer">defer</h2>

<p>Execute the next task in the sequence, but delay a bit, same as 
appending a wait(0) between current task and next task.
this is useful when you want to leave the main thread idle so runtime
can pick some more important task to process.</p>

<h3 id="parameters">Parameters</h3>

<ul>
<li>millisecond - Specify the millisecond to wait, default to 0;</li>
<li>args - The arguments to pass to next task</li>
</ul>

<h3 id="tips-and-annotations">Tips and Annotations</h3></div></div><div class="code"><div class="wrapper">  <span class="nx">p</span><span class="p">.</span><span class="nx">defer</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">millisecond</span><span class="p">,</span> <span class="nx">args</span><span class="p">){</span>

        <span class="kd">var</span> <span class="nx">ms</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>If millisecond is not given, the delay millisecond will be set to 0</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> 
            <span class="nx">millisecond</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> 
            <span class="nx">global</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">millisecond</span><span class="p">)){</span>
            <span class="nx">ms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="nx">ms</span> <span class="o">=</span> <span class="nx">millisecond</span><span class="p">;</span>
        <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>The millisecond is optional, if the first argument is not a number, it will be 
considered as arguments to the callback of next task</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="nx">args</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">global</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">millisecond</span><span class="p">)){</span>
            <span class="nx">args</span> <span class="o">=</span> <span class="nx">millisecond</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">scope</span><span class="p">.</span><span class="nx">go</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
        <span class="p">},</span> <span class="nx">ms</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="once">once</h2>

<p>Return a new callback, once any of the returned callbacks is called,
go to next step and ignore the other returned callbacks.</p></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h3 id="tips-and-annotation">Tips and Annotation</h3></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="nx">p</span><span class="p">.</span><span class="nx">once</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">cur</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">current</span><span class="p">(),</span>
      <span class="nx">go</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">go</span><span class="p">,</span>
      <span class="nx">scope</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li><p>If we already went to following task and then 1 callback is called 
we will ignore it.
In order to make sure below code can safely advance to next task: 
 var cb = this.once();
 this.go();
 cb();</p></li>
<li><p>When once() is used with all() together, if the callback of once() is
called, we advance the cursor and ignore the callbacks of all(), vise 
versa</p></li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="k">if</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">!==</span> <span class="nx">scope</span><span class="p">.</span><span class="nx">current</span><span class="p">()</span> <span class="o">||</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">went</span> <span class="o">===</span> <span class="kc">true</span><span class="p">){</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="nx">go</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="all">all</h2>

<p>Return a new callback each time <code>all()</code> is called, will go to next step 
once all returned callbacks are called</p></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h3 id="parameters">Parameters</h3>

<ul>
<li>key - a key to indicate the callback, later you can use this key to retrieve
the parameters.</li>
</ul>

<h3 id="tips-and-annotation">Tips and Annotation</h3>

<ul>
<li><p>It is suggested to call <code>all()</code> in the same synchronous context, if <code>all()</code>
is called in a delayed asynchronous context, the 'next task' may be executed
ealier then you expected.</p>

<pre><code>var r = Rytm(function(){


  doAnimate(this.all());


  // bbaaaaaaaad! DO NOT invoke all() in a delayed call
  // animation may be finished before someElement gets clicked
  // at that time, the only one callback was returned by 'all()'
  // thus, next task will be executed immedately.
  someElement.bind('click', function(){
    r.all();
  });
}, function(){
    blahblah();
});
</code></pre></li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="nx">p</span><span class="p">.</span><span class="nx">all</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">cur</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">current</span><span class="p">(),</span>
            <span class="nx">go</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">go</span><span class="p">,</span>
            <span class="nx">outerScope</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
            <span class="nx">argsIndex</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">lastCalls</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">cur</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>If all tasks are executed and then <code>all()</code> was called, 
it will return an <code>noop</code></li>
</ul></div></div><div class="code"><div class="wrapper">          <span class="k">return</span> <span class="nx">noop</span><span class="p">;</span>
        <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li><p>If the 'returned callback' is executed within the generating 
synchronous context, now Rytm will mondatorily delay the actual execution of 
next task in a asynchronous context.
This is to prevent a usage pitfall in old version of Rytm:</p>

<pre><code>s.step(function(){
    // this will cause problem if we don't delay the execution.
    // Because the first 'returned callback' will be executed 
    // immediately after it is produced and cause we advanced to next step
    // before 2nd all().
    executeTheCallbackImmediately(s.all());
    executeTheCallbackImmediately(s.all());
})
</code></pre>

<p>Here we tick the <code>cur</code> in an asychronous context to tell if the calling is 
happened async or sync</p></li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">ticked</span> <span class="o">===</span> <span class="kc">false</span><span class="p">){</span>
            <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
                <span class="nx">cur</span><span class="p">.</span><span class="nx">ticked</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
                <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">),</span>
                <span class="nx">l</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>If all() is used with the other method, such as once(), 'first
done first serv'.</li>
</ul></div></div><div class="code"><div class="wrapper">            <span class="k">if</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">!==</span> <span class="nx">outerScope</span><span class="p">.</span><span class="nx">current</span><span class="p">()</span> <span class="o">||</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">went</span> <span class="o">===</span> <span class="kc">true</span><span class="p">){</span>
                <span class="nx">cur</span><span class="p">.</span><span class="nx">lastCalls</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">cur</span><span class="p">.</span><span class="nx">ticked</span><span class="p">){</span>
                <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
                    <span class="k">return</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
                <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

                <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nx">cur</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="nx">argsIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">args</span><span class="p">;</span>
            <span class="nx">cur</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="nx">argsIndex</span><span class="p">].</span><span class="nx">key</span> <span class="o">=</span> <span class="nx">key</span><span class="p">;</span> 

            <span class="nx">l</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">lastCalls</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>

            <span class="k">while</span><span class="p">(</span><span class="nx">l</span><span class="o">--</span><span class="p">){</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">lastCalls</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">==</span> <span class="nx">ret</span><span class="p">){</span>
                    <span class="nx">cur</span><span class="p">.</span><span class="nx">lastCalls</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">lastCalls</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">){</span>
                        <span class="nx">go</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">args</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="nx">cur</span><span class="p">.</span><span class="nx">lastCalls</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>
    
        <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span> 
    <span class="p">};</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="next">next</h2>

<p>A reference to the next task.</p>

<p>The difference between <code>next</code> and <code>go</code> is:
once <code>go</code> gets called, we will immediately advance the internal cursor to next step
so if the <code>go</code> gets called multiple time, your tasks in sequence will be 
consumed faster then expected.
<code>next()</code> will make sure that the 'cursor advancing' actually is done in the <code>go()</code> 
call of the next task. </p>

<h3 id="tips-and-annotation">Tips and Annotation</h3></div></div><div class="code"><div class="wrapper">    <span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">cur</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">current</span><span class="p">(),</span>
            <span class="nx">go</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">go</span><span class="p">,</span> <span class="nx">result</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li><code>next()</code> will do nothing once <code>go()</code> gets called.</li>
</ul></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">went</span><span class="p">){</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">callback</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li>Private member <code>_inNextCallContext</code> indicates how many level of nested next() is called
correspondingly, later call to <code>go()</code> will have to skip the number of <code>_inNextCallContext</code>
tasks.</li>
</ul></div></div><div class="code"><div class="wrapper">            <span class="k">this</span><span class="p">.</span><span class="nx">_instance</span><span class="p">.</span><span class="nx">_inNextCallContext</span><span class="o">++</span><span class="p">;</span>

            <span class="nx">result</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">callback</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><ul>
<li><code>next</code> makes sure the behavior is the same as <code>go</code> when the task has return value.
Return anything other than undefine will cause advancing to next task immediately</li>
</ul></div></div><div class="code"><div class="wrapper">            <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="o">!==</span> <span class="nx">undef</span><span class="p">){</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">go</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_instance</span><span class="p">.</span><span class="nx">_inNextCallContext</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">_instance</span><span class="p">.</span><span class="nx">_inNextCallContext</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>

    <span class="p">};</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="taskcontext">TaskContext</h2>

<p><code>this</code> in task callback actually points to an instance of TaskContext,</p></div></div><div class="code"><div class="wrapper">    <span class="kd">function</span> <span class="nx">TaskContext</span><span class="p">(</span><span class="nx">rytm</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>TaskContext will make sure calls are fixed to current task.
For example, <code>next()</code> will always call to callback of next task even
when Rytm.cursor is advanced.</p></div></div><div class="code"><div class="wrapper">        <span class="k">this</span><span class="p">.</span><span class="nx">_current</span> <span class="o">=</span> <span class="nx">rytm</span><span class="p">.</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_instance</span> <span class="o">=</span> <span class="nx">rytm</span><span class="p">;</span>
    <span class="p">};</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="createtaskcontext">createTaskContext</h2>

<p>Create and return an instance of TaskContext, set current instance.<strong>proto</strong> to 
current instance of Rytm, so we can visit the data and method under current instance
of Rytm.</p></div></div><div class="code"><div class="wrapper">    <span class="kd">function</span> <span class="nx">createTaskContext</span><span class="p">(</span><span class="nx">rytm</span><span class="p">){</span>
        <span class="nx">TaskContext</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">rytm</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TaskContext</span><span class="p">(</span><span class="nx">rytm</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
    <span class="p">}</span>
  
  <span class="k">return</span> <span class="nx">Rytm</span><span class="p">;</span>
<span class="p">});</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h2 id="todo">TODO</h2></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h3 id="reverse">reverse</h3>

<h3 id="bounce">bounce</h3>

<p>If we are at the end, reverse the sequence and go</p></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h3 id="prev">prev</h3>

<p>Return prev beat</p></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h3 id="index">index</h3></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h3 id="reset">reset</h3></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h3 id="group">group</h3></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h3 id="dataparams">data/params</h3>

<p>To hold the parameters to next beat</p>

<h3 id="tests">tests</h3></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h3 id="dispose">dispose</h3>

<p>Release and destroy current instance (useful when trying to ignore any futher step )</p></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h3 id="strict-mode">strict mode</h3>

<p>go() cannot be called multiple times or used with the methods such as next()</p></div></div></div></div></body></html>